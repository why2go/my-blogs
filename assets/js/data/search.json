[ { "title": "redis使用bloom filter", "url": "/posts/redis%E4%BD%BF%E7%94%A8bloom-filter/", "categories": "redis, bloom", "tags": "redis, bloom", "date": "2022-06-09 00:00:00 +0800", "snippet": "什么是布隆过滤器？怎么用Redis实现布隆过滤器？Redis组件加载Redis Lab 和 阿里云增强型Redis" }, { "title": "OpenSSL", "url": "/posts/OpenSSL/", "categories": "openssl", "tags": "openssl", "date": "2021-09-07 00:00:00 +0800", "snippet": "OpenSSLTLS、证书、CA、公钥私钥等概念，在OpenSSL的实现中都有体现。可以通过对OpenSSL的学习，来逐步地了解上述的概念。描述OpenSSL是一个密码学工具箱，它实现了SSL（v2，v3）以及TLSv1，以及这些协议所使用到的密码学工具。它的主要用途有以下几个： 创建并管理私钥、公钥以及参数 公钥加密操作 创建X.509证书、CSR（证书签名请求）、CRL（证书回收列表） 消息摘要计算 使用密码工具来加密解密 SSL/TLS客户端和服务器测试 处理S/MIME签名或者加密邮件 时间戳请求、创建以及验证使用基本使用形式为：openssl command [ command_opts ] [ command_args ]OpenSSL支持很多的命令，使用openssl list -help可以查看支持的命令，如：$ openssl list -commandsasn1parse ca ciphers cms crl crl2pkcs7 dgst dhparam dsa dsaparam ec ecparam enc engine errstr gendsa genpkey genrsa help list nseq ocsp passwd pkcs12 pkcs7 pkcs8 pkey pkeyparam pkeyutl prime rand rehash req rsa rsautl s_client s_server s_time sess_id smime speed spkac srp storeutl ts verify version x509 生成公钥、私钥、证书生成私钥openssl genrsa -out private.pem 4096从私钥中得到公钥：openssl rsa -pubout -in private.pem -out public.pem从私钥中创建CSR（证书签名请求），CSR可以用于向CA请求证书：openssl req -new -sha256 -key private.pem -out sign.csr创建CSR也可以一步到位：openssl req -new -sha256 -nodes -newkey rsa:4096 -keyout pri.pem -out sign.csr创建自我签名的证书，包括生成私钥，使用-x509选项不再生成CSR：openssl req -x509 -sha256 -nodes -newkey rsa:4096 -keyout pri.pem -days 760 -out cert.pem使用-pubkey选项还能生成公钥查看证书的内容：openssl x509 -in cert.pem -text从证书中得到公钥：openssl x509 -in cert.pem -pubkey证书公钥基础设施系统 PKIpublic key infrastructure (PKI) systems，用来实现基于公钥密码体制的密钥和证书的产生、管理、存储、分发和撤销等功能。各个国家都有自己的PKI系统建设。证书签名请求 CSR应用向PKI中的注册机构发送消息，来请求一个电子身份证书。该消息是有一定的格式的，因此，在OpenSSL的使用中，会有req命令来构造csr，然后由csr生成证书，当然也可使用x509命令直接生成证书。PKCSPublic Key Cryptography Standards，公钥加密标准。这个名称是有RSA Security公司发布的一系列标准来的，对应的由RFC标准。PKCS由好多个group组成，不同的group表示为形如PKCS#10形式，用在不同的地方。如PKCS#1表示RSA加密解密，PKCS#10就是CSR。因此不同group描述的是不同的公私钥系统下的不同使用场景。X.509X.509是公钥证书、数字文档的一种标准格式，用它可以安全地将密钥对和身份标识联系起来。X.509的应用包括： SSL/TLS以及HTTPS，认证及加密网页浏览器 签名和加密Email，使用S/MIME协议密钥对和签名每个X.509证书都包括一个公钥、数字签名，以及证书相关者和发布证书的机构一方的身份信息。我们可以使用openssl命令来生成自我签名的证书，但是如果将自我签名的证书用在HTTPS中，浏览器会发出警告，使用curl访问时可以带上-k选项。" }, { "title": "JWT", "url": "/posts/JWT/", "categories": "jwt", "tags": "jwt", "date": "2021-09-07 00:00:00 +0800", "snippet": "JWTjwt由三部分组成：Header、Playload、Signature/EncryptionHeader和Playload是JSON对象。签名和加密依赖于使用的算法，如果jwt不进行签名或加密，则没有这一部分。Header头部用于说明jwt使用何种算法签名或加密，alg字段是必须要有的不加密jwt头部只有一个字段：{ &quot;alg&quot;: &quot;none&quot;}可选字段有：typ和ctytyp表示jwt媒介的类型，目的是为了区别JOSE头部，通常字段值都是JWTcty表示内容类型，许多jwt的负载都承载了其他的claim，此时不能出现该字段，除非JWT的载荷还是一个jwt，此时，cty的值是jwt。cty一般都不会出现。Playload载荷是一个JSON对象，由claim组成。jwt没有强制必须由哪些载荷，但是规范里定义了一些claim，这些claim有其固有的意义，称之为已注册claim。已经注册的claimiss：来自于issuer，大小写敏感的字串或URI构成，指代生成该jwt的一方。由应用指定意义。sub：来自于subject，大小写敏感的字串或URI构成，用于标识jwt的承载信息所指的一方，也就是载荷里的信息都是关于谁的，比如是一串userid，用来标识载荷信息是某用户的信息。由应用指定意义。aud：来自于audience，大小写敏感的字串或URI，读取该jwt的一方需要满足该字段意义，不然不应该读取。由应用指定意义。exp：来自于expiration，JSON里面的数字类型，用于表示该jwt的过期时间，意义是seconds since epoch，也就是POSIX中1970年之后的秒数。过期之后，jwt变为invalid。nbf：和exp的意义相反，内容也是秒数，但是该jwt在过了该时间点之后才valid。iat：issued at，也是秒数，表示jwt的创建时间点。jti：JWT ID，用于表示一个jwt，用在jwt内容相似时，主要用于区分jwt，具体含义看实现。公有、私有claim一般jwt中都会包含private claim，用于承载额外的信息。签名JWT吸引人们关注的地方就在于它带有签名，签名是对Header和Playload部分进行的，而后将签名字段作为第三部分。JWT规定了一系列的签名算法，各种语言下类库提供了丰富的支持。golang-jwt 使用这一节以golang为例，介绍jwt如何进行签名与验证签名。签名方法的使用：func TestSignature(t *testing.T) { type Book struct { Title string `json:&quot;title&quot;` Page int `json:&quot;page&quot;` } type BookClaims struct { Book Book `json:&quot;book&quot;` jwt.StandardClaims } book := Book{ Title: &quot;伦理学与生活&quot;, Page: 1123, } // 构造claims claims := BookClaims{ // 加入自定义的claims book, // 加入标准的claims jwt.StandardClaims{ Issuer: &quot;why2go&quot;, IssuedAt: time.Now().Unix(), ExpiresAt: time.Now().Add(time.Hour).Unix(), Subject: &quot;book&quot;, }, } // 测试HMAC签名与验证 t.Run(&quot;HMAC&quot;, func(t *testing.T) { // HMAC需要sharedSecret来计算签名 sharedSecret := []byte(&quot;hello&quot;) token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) // 得到签名后的jwt字串 signedToken, err := token.SignedString(sharedSecret) if err != nil { panic(err) } fmt.Println(signedToken) wrongSecret := []byte(&quot;hi&quot;) // 使用Parse来解析jwt字串 parsedToken, err := jwt.Parse(signedToken, func(t *jwt.Token) (interface{}, error) { // 先验证jwt使用的算法是否正确 if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok { return nil, fmt.Errorf(&quot;unexpected signing method: %v&quot;, t.Header[&quot;alg&quot;]) } // 在这里返回sharedSecret return wrongSecret, nil }) // 如果验证jwt失败，则出错 if err != nil { panic(err) } fmt.Printf(&quot;%+v\\n&quot;, parsedToken) // 注意：即使签名正确，jwt也有可能已经过期 }) // 测试RSA方式的签名与验证 t.Run(&quot;RSA&quot;, func(t *testing.T) { privateKey, err := rsa.GenerateKey(rand.Reader, 2048) if err != nil { panic(err) } publicKey := &amp;amp;privateKey.PublicKey // 使用RS256方式签名 unsignedToken := jwt.NewWithClaims(jwt.SigningMethodRS256, claims) // 使用私钥签名 signedToken, err := unsignedToken.SignedString(privateKey) if err != nil { panic(err) } fmt.Println(&quot;here is signed token:&quot;) fmt.Println(signedToken) // 使用公钥验证签名 parsedToken, err := jwt.Parse(signedToken, func(token *jwt.Token) (interface{}, error) { if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok { return nil, fmt.Errorf(&quot;unexpected signing method: %v&quot;, token.Header[&quot;alg&quot;]) } return publicKey, nil }) if err != nil { panic(err) } token, err := json.Marshal(parsedToken) if err != nil { panic(err) } fmt.Printf(&quot;%s\\n&quot;, token) })}需要注意的是，签名算法的不同，传入的key的类型也不同：Each signing method expects a different object type for its signing keys. See the package documentation for details. Here are the most common ones: The HMAC signing method (HS256,HS384,HS512) expect []byte values for signing and validation The RSA signing method (RS256,RS384,RS512) expect *rsa.PrivateKey for signing and *rsa.PublicKey for validation The ECDSA signing method (ES256,ES384,ES512) expect *ecdsa.PrivateKey for signing and *ecdsa.PublicKey for validation" }, { "title": "docker搭建mongodb集群", "url": "/posts/docker%E6%90%AD%E5%BB%BAmongodb%E9%9B%86%E7%BE%A4/", "categories": "mongodb, docker", "tags": "mongodb, docker", "date": "2021-08-07 00:00:00 +0800", "snippet": "本文按照mongodb网站上的指导教程使用docker搭建了一个shard集群，供学习参考。该配置适用于Linux系统，Mac系统上的docker网络实现与Linux不相同，宿主机与容器通信会存在问题，需要另行处理。现有如下目录结构：.├── docker-compose.yaml└── shard-setup └── setup.sh其中，docker-compose.yaml内容如下，文章撰写时，mongodb版本最新为5.0.0：version: &quot;3.8&quot;services: shard-setup: hostname: shard-setup container_name: shard-setup image: mongo:5.0.0 entrypoint: /usr/bin/bash /shard-setup/setup.sh volumes: - ./shard-setup:/shard-setup networks: - mongo-shard-net depends_on: - mongos-1 restart: &quot;no&quot; mongos-1: hostname: mongos-1 container_name: mongos-1 image: mongo:5.0.0 entrypoint: - &quot;mongos&quot; - &quot;--configdb&quot; - &quot;cfgrs0/cfgrs0-1:27019,cfgrs0-2:27019,cfgrs0-3:27019&quot; - &quot;--bind_ip_all&quot; networks: mongo-shard-net: ipv4_address: 172.28.0.51 expose: - 27017 restart: on-failure depends_on: - cfgrs0-1 - cfgrs0-2 - cfgrs0-3 - dbrs0-1 - dbrs0-2 - dbrs0-3 - dbrs1-1 - dbrs1-2 - dbrs1-3 cfgrs0-1: hostname: cfgrs0-1 container_name: cfgrs0-1 image: mongo:5.0.0 entrypoint: /usr/bin/mongod --configsvr --replSet &quot;cfgrs0&quot; --bind_ip_all networks: - mongo-shard-net restart: on-failure expose: - &quot;27019&quot; cfgrs0-2: hostname: cfgrs0-2 container_name: cfgrs0-2 image: mongo:5.0.0 entrypoint: /usr/bin/mongod --configsvr --replSet &quot;cfgrs0&quot; --bind_ip_all networks: - mongo-shard-net restart: on-failure expose: - &quot;27019&quot; cfgrs0-3: hostname: cfgrs0-3 container_name: cfgrs0-3 image: mongo:5.0.0 entrypoint: /usr/bin/mongod --configsvr --replSet &quot;cfgrs0&quot; --bind_ip_all networks: - mongo-shard-net restart: on-failure expose: - &quot;27019&quot; # 配置dbrs0和dbrs1 dbrs0-1: hostname: dbrs0-1 container_name: dbrs0-1 image: mongo:5.0.0 entrypoint: /usr/bin/mongod --shardsvr --replSet &quot;dbrs0&quot; --bind_ip_all networks: - mongo-shard-net restart: on-failure expose: - &quot;27018&quot; dbrs0-2: hostname: dbrs0-2 container_name: dbrs0-2 image: mongo:5.0.0 entrypoint: /usr/bin/mongod --shardsvr --replSet &quot;dbrs0&quot; --bind_ip_all networks: - mongo-shard-net restart: on-failure expose: - &quot;27018&quot; dbrs0-3: hostname: dbrs0-3 container_name: dbrs0-3 image: mongo:5.0.0 entrypoint: /usr/bin/mongod --shardsvr --replSet &quot;dbrs0&quot; --bind_ip_all networks: - mongo-shard-net restart: on-failure expose: - &quot;27018&quot; dbrs1-1: hostname: dbrs1-1 container_name: dbrs1-1 image: mongo:5.0.0 entrypoint: /usr/bin/mongod --shardsvr --replSet &quot;dbrs1&quot; --bind_ip_all networks: - mongo-shard-net restart: on-failure expose: - &quot;27018&quot; dbrs1-2: hostname: dbrs1-2 container_name: dbrs1-2 image: mongo:5.0.0 entrypoint: /usr/bin/mongod --shardsvr --replSet &quot;dbrs1&quot; --bind_ip_all networks: - mongo-shard-net restart: on-failure expose: - &quot;27018&quot; dbrs1-3: hostname: dbrs1-3 container_name: dbrs1-3 image: mongo:5.0.0 entrypoint: /usr/bin/mongod --shardsvr --replSet &quot;dbrs1&quot; --bind_ip_all networks: - mongo-shard-net restart: on-failure expose: - &quot;27018&quot;networks: mongo-shard-net: name: mongo-shard-net ipam: config: - subnet: 172.28.0.0/16setup.sh用于设置config以及shard主从，内容如下：#/bin/bashCFGRS0_NAME=cfgrs0CFGRS0_REPLICA_1=${CFGRS0_NAME}-1CFGRS0_REPLICA_2=${CFGRS0_NAME}-2CFGRS0_REPLICA_3=${CFGRS0_NAME}-3CFGSVR_PORT=27019DBRS0_NAME=dbrs0DBRS0_REPLICA_1=${DBRS0_NAME}-1DBRS0_REPLICA_2=${DBRS0_NAME}-2DBRS0_REPLICA_3=${DBRS0_NAME}-3DBRS1_NAME=dbrs1DBRS1_REPLICA_1=${DBRS1_NAME}-1DBRS1_REPLICA_2=${DBRS1_NAME}-2DBRS1_REPLICA_3=${DBRS1_NAME}-3DBSVR_PORT=27018until mongosh --host ${CFGRS0_REPLICA_1} --port ${CFGSVR_PORT} --quiet &amp;lt;&amp;lt;EOFexitEOFdo sleep 5donemongosh --host ${CFGRS0_REPLICA_1} --port ${CFGSVR_PORT} --quiet &amp;lt;&amp;lt;EOFrs.initiate( { _id: &quot;${CFGRS0_NAME}&quot;, configsvr: true, members: [ { _id : 0, host : &quot;${CFGRS0_REPLICA_1}:${CFGSVR_PORT}&quot;, priority: 2 }, { _id : 1, host : &quot;${CFGRS0_REPLICA_2}:${CFGSVR_PORT}&quot;, priority: 1 }, { _id : 2, host : &quot;${CFGRS0_REPLICA_3}:${CFGSVR_PORT}&quot;, priority: 1 } ] })EOFfor rs in 0 1do until mongosh --host `eval echo &#39;$&#39;{DBRS&quot;${rs}&quot;_REPLICA_1}` --port ${DBSVR_PORT} --quiet &amp;lt;&amp;lt;EOFexitEOF do sleep 5 donemongosh --host `eval echo &#39;$&#39;{DBRS&quot;${rs}&quot;_REPLICA_1}` --port ${DBSVR_PORT} --quiet &amp;lt;&amp;lt;EOFrs.initiate( { _id: &quot;`eval echo &#39;$&#39;{DBRS&quot;${rs}&quot;_NAME}`&quot;, members: [ { _id : 0, host : &quot;`eval echo &#39;$&#39;{DBRS&quot;${rs}&quot;_REPLICA_1}`:${DBSVR_PORT}&quot;, priority: 2 }, { _id : 1, host : &quot;`eval echo &#39;$&#39;{DBRS&quot;${rs}&quot;_REPLICA_2}`:${DBSVR_PORT}&quot;, priority: 1 }, { _id : 2, host : &quot;`eval echo &#39;$&#39;{DBRS&quot;${rs}&quot;_REPLICA_3}`:${DBSVR_PORT}&quot;, priority: 1 } ] })EOFdone# mongos --configdb ${CFGRS0_NAME}/${CFGRS0_REPLICA_1}:${CFGSVR_PORT},\\# ${CFGRS0_REPLICA_2}:${CFGSVR_PORT},${CFGRS0_REPLICA_3}:${CFGSVR_PORT} \\# --bind_ip_all &amp;amp;MONGOS=mongos-1# 配置sharduntil mongosh --host ${MONGOS} --quiet &amp;lt;&amp;lt;EOFexitEOFdo sleep 5donemongosh --host ${MONGOS} --quiet &amp;lt;&amp;lt;EOFsh.addShard(&quot;${DBRS0_NAME}/${DBRS0_REPLICA_1}:${DBSVR_PORT},${DBRS0_REPLICA_2}:${DBSVR_PORT},${DBRS0_REPLICA_3}:${DBSVR_PORT}&quot;)sh.addShard(&quot;${DBRS1_NAME}/${DBRS1_REPLICA_1}:${DBSVR_PORT},${DBRS1_REPLICA_2}:${DBSVR_PORT},${DBRS1_REPLICA_3}:${DBSVR_PORT}&quot;)EOF使用docker-compose up即可启动集群，使用docker-compose down --volumes即可停止并删除集群。使用docker-compose stop可以保存此次启动的集群容器，下次使用docker-compose start启动既可以恢复，可以看到上次启动时mongodb保存的数据。PS：仅使用docker-compose down可能会致使磁盘空间不断减小，每次挂载的volume在/var/lib/docker目录下会越积越多。" } ]
